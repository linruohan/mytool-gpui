# 用户编码规范与重构指南

## 基础交互规则

1. 请用中文回答我
2. 如果回答的是代码，请给每个关键节点，比较难懂的代码增加中文注释
3. 当生成的代码行数超过 20 行时，请考虑聚合代码以及考虑其颗粒度是否适合

## 代码质量与重构规范

### 通用编码规范

1. 避免不必要的对象复制或克隆
2. 避免多层嵌套，提前返回
3. 使用适当的并发控制机制

## 代码坏味道识别与处理

基于Martin Fowler《重构》一书的核心观点，以下是应当注意的代码坏味道及其处理方法：

### 1. 神秘命名

- **问题**：变量、函数、类或模块的名称不能清晰表达其用途和含义
- **处理**：重命名为具有描述性的名称，使代码自解释
- **示例**：将`fn p()`改为`fn calculate_price()`

### 2. 重复代码

- **问题**：相同或相似的代码出现在多个地方
- **处理**：提取为函数、类或模块；应用模板方法模式
- **示例**：将重复的验证逻辑提取为共享函数

### 3. 过长函数

- **问题**：函数过长，难以理解和维护
- **处理**：提取函数，将大函数分解为多个小函数
- **示例**：将200行的处理函数分解为多个职责单一的小函数

### 4. 过大的类/结构体

- **问题**：类或结构体承担了过多责任，字段和方法过多
- **处理**：提取类，将相关字段和方法组合成新的类
- **示例**：将User类中的地址相关字段提取为Address类

### 5. 过长参数列表

- **问题**：函数参数过多，难以理解和使用
- **处理**：引入参数对象，将相关参数组合成对象
- **示例**：将`fn create_user(name, email, phone, address, city, country)`改为`fn create_user(user_info: UserInfo)`

### 6. 发散式变化

- **问题**：一个类因为多种原因而被修改
- **处理**：按照变化原因拆分类
- **示例**：将既处理数据库又处理业务逻辑的类拆分为两个类

### 7. 霰弹式修改

- **问题**：一次修改需要改动多个类
- **处理**：将相关功能移到同一个类中
- **示例**：将分散在多个类中的订单处理逻辑合并到一个OrderProcessor类

### 8. 依恋情结

- **问题**：一个函数对其他类的兴趣超过自己所在的类
- **处理**：移动函数或提取函数
- **示例**：将过度使用另一个类数据的方法移动到那个类中

### 9. 数据泥团

- **问题**：相同的数据项总是一起出现
- **处理**：提取为对象
- **示例**：将经常一起出现的起始日期和结束日期提取为DateRange类

### 10. 基本类型偏执

- **问题**：使用基本类型表示有特定含义的数据
- **处理**：使用小对象替代基本类型
- **示例**：用PhoneNumber类替代表示电话的字符串

## 重构过程原则

### 1. 小步重构

- 每次只做一个小改动，然后测试
- 频繁提交，保持代码随时可工作

### 2. 测试保障

- 重构前确保有足够的测试覆盖
- 每次修改后运行测试确保行为不变

### 3. 代码审查

- 重构后进行代码审查，确保质量
- 分享重构经验，提高团队能力

## 代码可读性优化

### 1. 命名约定

- 使用有意义的、描述性的名称
- 遵循项目或语言的命名规范
- 避免缩写和单字母变量（除非是约定俗成的，如循环中的i）

### 2. 代码组织

- 相关代码应该放在一起
- 函数应该只做一件事
- 保持适当的抽象层次

### 3. 注释与文档

- 注释应该解释为什么，而不是做什么
- 为公共API提供清晰的文档
- 更新注释以反映代码变化

## 性能相关重构

### 1. 内存优化

- 避免不必要的对象创建
- 及时释放不再需要的资源
- 注意内存泄漏问题

### 2. 计算优化

- 避免重复计算
- 使用适当的数据结构和算法
- 延迟计算直到必要时

### 3. 并行优化

- 识别可并行化的任务
- 避免不必要的同步
- 注意线程安全问题

## 通用礼节 (General Etiquette)

- 优先保证代码简洁易懂。
- 别搞过度设计，简单实用就好。
- 写代码时，要注意圈复杂度，函数尽量小，尽量可以复用，尽量不写重复代码。
- 写代码时，注意模块设计，尽量使用设计模式。
- 给我解释代码的时候，说人话，别拽专业术语。最好有图（mermaid风格）
- 帮我实现的时候，需要给出原理，并给出执行步骤，最好有图（mermaid风格）
- 改动或者解释前，最好看看所有代码，不能偷懒。
- 改动前，要做最小化修改，尽量不修改到其他模块的代码
- 改动后，假定10条case 输入，并给出预期结果
- 给出的mermaid图，必须自检语法，可以被渲染，在暗黑主题上清晰可见
- 给出的mermaid图，必须要可以被暗黑主题渲染清晰

# 实验性规则 (Experimental Rule)

当你被要求修复一个 Bug 时，请遵循以下步骤：

1.  **理解问题 (Understand):** 仔细阅读 Bug 描述和相关代码，复述你对问题的理解。
2.  **分析原因 (Analyze):** 提出至少两种可能的根本原因。
3.  **制定计划 (Plan):** 描述你打算如何验证这些原因，并给出修复方案。
4.  **请求确认 (Confirm):** 在动手修改前，向我确认你的计划。
5.  **执行修复 (Execute):** 实施修复。
6.  **审查 (Review):** 查看自己的修改有没有问题。
7.  **解释说明 (Explain):** 解释你做了哪些修改以及为什么。

# MCP Interactive Feedback 规则

1. 在任何流程、任务、对话进行时，无论是询问、回复、或完成阶段性任务，皆必须调用 MCP mcp-feedback-enhanced。
2. 每当收到用户反馈，若反馈内容非空，必须再次调用 MCP mcp-feedback-enhanced，并根据反馈内容调整行为。
3. 仅当用户明确表示「结束」或「不再需要交互」时，才可停止调用 MCP mcp-feedback-enhanced，流程才算结束。
4. 除非收到结束指令，否则所有步骤都必须重复调用 MCP mcp-feedback-enhanced。
5. 完成任务前，必须使用 MCP mcp-feedback-enhanced 工具向用户询问反馈。

Always respond in 中文
